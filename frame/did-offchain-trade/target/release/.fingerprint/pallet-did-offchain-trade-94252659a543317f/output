{"message":"unused imports: `Hash`, `IdentifyAccount`, `Member`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":284,"byte_end":288,"line_start":10,"line_end":10,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"use sp_runtime::traits::{Hash, IdentifyAccount, Member, Verify};","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":290,"byte_end":305,"line_start":10,"line_end":10,"column_start":32,"column_end":47,"is_primary":true,"text":[{"text":"use sp_runtime::traits::{Hash, IdentifyAccount, Member, Verify};","highlight_start":32,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":307,"byte_end":313,"line_start":10,"line_end":10,"column_start":49,"column_end":55,"is_primary":true,"text":[{"text":"use sp_runtime::traits::{Hash, IdentifyAccount, Member, Verify};","highlight_start":49,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":284,"byte_end":315,"line_start":10,"line_end":10,"column_start":26,"column_end":57,"is_primary":true,"text":[{"text":"use sp_runtime::traits::{Hash, IdentifyAccount, Member, Verify};","highlight_start":26,"highlight_end":57}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `Hash`, `IdentifyAccount`, `Member`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:10:26\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse sp_runtime::traits::{Hash, IdentifyAccount, Member, Verify};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused import: `sr25519`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":439,"byte_end":446,"line_start":13,"line_end":13,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"use sp_core::{RuntimeDebug, sr25519, Pair};","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":437,"byte_end":446,"line_start":13,"line_end":13,"column_start":27,"column_end":36,"is_primary":true,"text":[{"text":"use sp_core::{RuntimeDebug, sr25519, Pair};","highlight_start":27,"highlight_end":36}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `sr25519`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:13:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse sp_core::{RuntimeDebug, sr25519, Pair};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"message":"no function or associated item named `boolean_owner` found for struct `pallet_did::Module<T>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2877,"byte_end":2890,"line_start":94,"line_end":94,"column_start":44,"column_end":57,"is_primary":true,"text":[{"text":"\t\t\tlet isPlayer1: bool = <did::Module<T>>::boolean_owner(&did, &players[0]);","highlight_start":44,"highlight_end":57}],"label":"function or associated item not found in `pallet_did::Module<T>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the method `boolean_owner` exists but the following trait bounds were not satisfied:\n`T : pallet_did::Trait`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no function or associated item named `boolean_owner` found for struct `pallet_did::Module<T>` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:94:44\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let isPlayer1: bool = <did::Module<T>>::boolean_owner(&did, &players[0]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfunction or associated item not found in `pallet_did::Module<T>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the method `boolean_owner` exists but the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `T : pallet_did::Trait`\u001b[0m\n\n"}
{"message":"the trait bound `T: pallet_did::Trait` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2860,"byte_end":2874,"line_start":94,"line_end":94,"column_start":27,"column_end":41,"is_primary":true,"text":[{"text":"\t\t\tlet isPlayer1: bool = <did::Module<T>>::boolean_owner(&did, &players[0]);","highlight_start":27,"highlight_end":41}],"label":"the trait `pallet_did::Trait` is not implemented for `T`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2453,"byte_end":2454,"line_start":79,"line_end":79,"column_start":20,"column_end":21,"is_primary":false,"text":[{"text":"\tpub struct Module<T: Trait> for enum Call where origin: T::Origin {","highlight_start":20,"highlight_end":21}],"label":"consider adding a `where T: pallet_did::Trait` bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by `pallet_did::Module`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `T: pallet_did::Trait` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:94:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub struct Module<T: Trait> for enum Call where origin: T::Origin {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider adding a `where T: pallet_did::Trait` bound\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let isPlayer1: bool = <did::Module<T>>::boolean_owner(&did, &players[0]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `pallet_did::Trait` is not implemented for `T`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required by `pallet_did::Module`\u001b[0m\n\n"}
{"message":"no function or associated item named `boolean_owner` found for struct `pallet_did::Module<T>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2954,"byte_end":2967,"line_start":95,"line_end":95,"column_start":44,"column_end":57,"is_primary":true,"text":[{"text":"\t\t\tlet isPlayer2: bool = <did::Module<T>>::boolean_owner(&did, &players[1]);","highlight_start":44,"highlight_end":57}],"label":"function or associated item not found in `pallet_did::Module<T>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the method `boolean_owner` exists but the following trait bounds were not satisfied:\n`T : pallet_did::Trait`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no function or associated item named `boolean_owner` found for struct `pallet_did::Module<T>` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:95:44\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m95\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let isPlayer2: bool = <did::Module<T>>::boolean_owner(&did, &players[1]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfunction or associated item not found in `pallet_did::Module<T>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the method `boolean_owner` exists but the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `T : pallet_did::Trait`\u001b[0m\n\n"}
{"message":"the trait bound `T: pallet_did::Trait` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2937,"byte_end":2951,"line_start":95,"line_end":95,"column_start":27,"column_end":41,"is_primary":true,"text":[{"text":"\t\t\tlet isPlayer2: bool = <did::Module<T>>::boolean_owner(&did, &players[1]);","highlight_start":27,"highlight_end":41}],"label":"the trait `pallet_did::Trait` is not implemented for `T`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2453,"byte_end":2454,"line_start":79,"line_end":79,"column_start":20,"column_end":21,"is_primary":false,"text":[{"text":"\tpub struct Module<T: Trait> for enum Call where origin: T::Origin {","highlight_start":20,"highlight_end":21}],"label":"consider adding a `where T: pallet_did::Trait` bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by `pallet_did::Module`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `T: pallet_did::Trait` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:95:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub struct Module<T: Trait> for enum Call where origin: T::Origin {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider adding a `where T: pallet_did::Trait` bound\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m95\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let isPlayer2: bool = <did::Module<T>>::boolean_owner(&did, &players[1]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `pallet_did::Trait` is not implemented for `T`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required by `pallet_did::Module`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":3294,"byte_end":3450,"line_start":102,"line_end":110,"column_start":26,"column_end":5,"is_primary":true,"text":[{"text":"\t\t\tlet mut didKey: u32 = |_didKey| {","highlight_start":26,"highlight_end":37},{"text":"\t\t\t\tlet mut _didKey = Self::did_key();","highlight_start":1,"highlight_end":39},{"text":"\t\t\t\tif _didKey == 0 || _didKey == 1 {","highlight_start":1,"highlight_end":38},{"text":"\t\t\t\t\t_didKey = 2;","highlight_start":1,"highlight_end":18},{"text":"\t\t\t\t\t_didKey","highlight_start":1,"highlight_end":13},{"text":"\t\t\t\t} else {","highlight_start":1,"highlight_end":13},{"text":"\t\t\t\t\t_didKey","highlight_start":1,"highlight_end":13},{"text":"\t\t\t\t}","highlight_start":1,"highlight_end":6},{"text":"\t\t\t};","highlight_start":1,"highlight_end":5}],"label":"expected `u32`, found closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":3288,"byte_end":3291,"line_start":102,"line_end":102,"column_start":20,"column_end":23,"is_primary":false,"text":[{"text":"\t\t\tlet mut didKey: u32 = |_didKey| {","highlight_start":20,"highlight_end":23}],"label":"expected due to this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type `u32`\nfound closure `[closure@src/lib.rs:102:26: 110:5]`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:102:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m            let mut didKey: u32 = |_didKey| {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m_____________________________\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m___^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected due to this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let mut _didKey = Self::did_key();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if _didKey == 0 || _didKey == 1 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    _didKey = 2;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found closure\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type `\u001b[0m\u001b[0m\u001b[1mu32\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m            found closure `\u001b[0m\u001b[0m\u001b[1m[closure@src/lib.rs:102:26: 110:5]\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":4525,"byte_end":4532,"line_start":143,"line_end":143,"column_start":42,"column_end":49,"is_primary":true,"text":[{"text":"\t\t\tSelf::valid_signers(transaction.sigs, encoded, players)?;","highlight_start":42,"highlight_end":49}],"label":"expected `&[u8]`, found struct `std::vec::Vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&[u8]`\n      found struct `std::vec::Vec<u8>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":4525,"byte_end":4532,"line_start":143,"line_end":143,"column_start":42,"column_end":49,"is_primary":true,"text":[{"text":"\t\t\tSelf::valid_signers(transaction.sigs, encoded, players)?;","highlight_start":42,"highlight_end":49}],"label":null,"suggested_replacement":"&encoded","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:143:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m143\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            Self::valid_signers(transaction.sigs, encoded, players)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `&[u8]`, found struct `std::vec::Vec`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: consider borrowing here: `&encoded`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected reference `\u001b[0m\u001b[0m\u001b[1m&[u8]\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                  found struct `\u001b[0m\u001b[0m\u001b[1mstd::vec::Vec<u8>\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"no field `seqNum` on type `StateProof<sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::MultiSignature>`","code":{"code":"E0609","explanation":"Attempted to access a non-existent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":4938,"byte_end":4944,"line_start":152,"line_end":152,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"\t\t\t\t\tseqNum: transaction.seqNum,","highlight_start":26,"highlight_end":32}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `appState`, `sigs`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0609]\u001b[0m\u001b[0m\u001b[1m: no field `seqNum` on type `StateProof<sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::MultiSignature>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:152:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m152\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    seqNum: transaction.seqNum,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munknown field\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: available fields are: `appState`, `sigs`\u001b[0m\n\n"}
{"message":"no field `seqNum` on type `StateProof<sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::MultiSignature>`","code":{"code":"E0609","explanation":"Attempted to access a non-existent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":5540,"byte_end":5546,"line_start":170,"line_end":170,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"\t\t\t\t\tseqNum: transaction.seqNum,","highlight_start":26,"highlight_end":32}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `appState`, `sigs`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0609]\u001b[0m\u001b[0m\u001b[1m: no field `seqNum` on type `StateProof<sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::MultiSignature>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:170:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m170\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    seqNum: transaction.seqNum,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munknown field\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: available fields are: `appState`, `sigs`\u001b[0m\n\n"}
{"message":"no field `appStete` on type `StateProof<sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::MultiSignature>`","code":{"code":"E0609","explanation":"Attempted to access a non-existent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":5979,"byte_end":5987,"line_start":185,"line_end":185,"column_start":48,"column_end":56,"is_primary":true,"text":[{"text":"\t\t\t\tlet did = match Self::did_list(transaction.appStete.state) {","highlight_start":48,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a field with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":5979,"byte_end":5987,"line_start":185,"line_end":185,"column_start":48,"column_end":56,"is_primary":true,"text":[{"text":"\t\t\t\tlet did = match Self::did_list(transaction.appStete.state) {","highlight_start":48,"highlight_end":56}],"label":null,"suggested_replacement":"appState","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0609]\u001b[0m\u001b[0m\u001b[1m: no field `appStete` on type `StateProof<sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::MultiSignature>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:185:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m185\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let did = match Self::did_list(transaction.appStete.state) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a field with a similar name exists: `appState`\u001b[0m\n\n"}
{"message":"no variant or associated item named `InvalidState` found for enum `Error<T>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n"},"level":"error","spans":[{"file_name":"<::frame_support::error::decl_error macros>","byte_start":257,"byte_end":564,"line_start":6,"line_end":13,"column_start":22,"column_end":6,"is_primary":false,"text":[{"text":"    $ (# [$ attr]) * pub enum $ error < $ generic : $ trait $","highlight_start":22,"highlight_end":62},{"text":"    (, $ inst_generic : $ instance) ? >","highlight_start":1,"highlight_end":40},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        # [doc (hidden)] __Ignore","highlight_start":1,"highlight_end":34},{"text":"        ($ crate :: sp_std :: marker :: PhantomData <","highlight_start":1,"highlight_end":54},{"text":"         ($ generic, $ ($ inst_generic) ?) >, $ crate :: dispatch :: Never,),","highlight_start":1,"highlight_end":78},{"text":"        $ ($ (# [doc = $ doc_attr]) * $ name), *","highlight_start":1,"highlight_end":49},{"text":"    } impl < $ generic : $ trait $ (, $ inst_generic : $ instance) ? > $ crate","highlight_start":1,"highlight_end":6}],"label":"variant or associated item `InvalidState` not found here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10892,"byte_end":11109,"line_start":395,"line_end":407,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"decl_error! {","highlight_start":1,"highlight_end":14},{"text":"\tpub enum Error for Module<T: Trait> {","highlight_start":1,"highlight_end":39},{"text":"\t\tNotOwner,","highlight_start":1,"highlight_end":12},{"text":"\t\tInvalidPlayerLength,","highlight_start":1,"highlight_end":23},{"text":"\t\tInvalidSender,","highlight_start":1,"highlight_end":17},{"text":"\t\tInvalidNonce,","highlight_start":1,"highlight_end":16},{"text":"\t\tInvalidSeqNum,","highlight_start":1,"highlight_end":17},{"text":"\t\tInvalidSignature,","highlight_start":1,"highlight_end":20},{"text":"\t\tInvalidConditionAddress,","highlight_start":1,"highlight_end":27},{"text":"\t\tNotExist,","highlight_start":1,"highlight_end":12},{"text":"\t\tExistAddress,","highlight_start":1,"highlight_end":16},{"text":"\t}","highlight_start":1,"highlight_end":3},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"decl_error!","def_site_span":{"file_name":"<::frame_support::error::decl_error macros>","byte_start":0,"byte_end":3640,"line_start":1,"line_end":91,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * pub enum $ error : ident for $ module : ident < $","highlight_start":1,"highlight_end":75},{"text":" generic : ident : $ trait : path $","highlight_start":1,"highlight_end":36},{"text":" (, $ inst_generic : ident : $ instance : path) ? >","highlight_start":1,"highlight_end":52},{"text":" { $ ($ (# [doc = $ doc_attr : tt]) * $ name : ident), * $ (,) ? }) =>","highlight_start":1,"highlight_end":71},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ (# [$ attr]) * pub enum $ error < $ generic : $ trait $","highlight_start":1,"highlight_end":62},{"text":"    (, $ inst_generic : $ instance) ? >","highlight_start":1,"highlight_end":40},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        # [doc (hidden)] __Ignore","highlight_start":1,"highlight_end":34},{"text":"        ($ crate :: sp_std :: marker :: PhantomData <","highlight_start":1,"highlight_end":54},{"text":"         ($ generic, $ ($ inst_generic) ?) >, $ crate :: dispatch :: Never,),","highlight_start":1,"highlight_end":78},{"text":"        $ ($ (# [doc = $ doc_attr]) * $ name), *","highlight_start":1,"highlight_end":49},{"text":"    } impl < $ generic : $ trait $ (, $ inst_generic : $ instance) ? > $ crate","highlight_start":1,"highlight_end":79},{"text":"    :: sp_std :: fmt :: Debug for $ error < $ generic $ (, $ inst_generic) ? >","highlight_start":1,"highlight_end":79},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        fn fmt","highlight_start":1,"highlight_end":15},{"text":"        (& self, f : & mut $ crate :: sp_std :: fmt :: Formatter < '_ >) -> $","highlight_start":1,"highlight_end":78},{"text":"        crate :: sp_std :: fmt :: Result { f . write_str (self . as_str ()) }","highlight_start":1,"highlight_end":78},{"text":"    } impl < $ generic : $ trait $ (, $ inst_generic : $ instance) ? > $ error","highlight_start":1,"highlight_end":79},{"text":"    < $ generic $ (, $ inst_generic) ? >","highlight_start":1,"highlight_end":41},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        fn as_u8 (& self) -> u8","highlight_start":1,"highlight_end":32},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            $ crate :: decl_error !","highlight_start":1,"highlight_end":36},{"text":"            { @ GENERATE_AS_U8 self $ error { } 0, $ ($ name), * }","highlight_start":1,"highlight_end":67},{"text":"        } fn as_str (& self) -> & 'static str","highlight_start":1,"highlight_end":46},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            match self","highlight_start":1,"highlight_end":23},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                Self :: __Ignore (_, _) => unreachable !","highlight_start":1,"highlight_end":57},{"text":"                (\"`__Ignore` can never be constructed\"), $","highlight_start":1,"highlight_end":59},{"text":"                ($ error :: $ name => stringify ! ($ name),) *","highlight_start":1,"highlight_end":63},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } impl < $ generic : $ trait $ (, $ inst_generic : $ instance) ? > From <","highlight_start":1,"highlight_end":78},{"text":"    $ error < $ generic $ (, $ inst_generic) ? >> for & 'static str","highlight_start":1,"highlight_end":68},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        fn from (err : $ error < $ generic $ (, $ inst_generic) ? >) -> &","highlight_start":1,"highlight_end":74},{"text":"        'static str { err . as_str () }","highlight_start":1,"highlight_end":40},{"text":"    } impl < $ generic : $ trait $ (, $ inst_generic : $ instance) ? > From <","highlight_start":1,"highlight_end":78},{"text":"    $ error < $ generic $ (, $ inst_generic) ? >> for $ crate :: sp_runtime ::","highlight_start":1,"highlight_end":79},{"text":"    DispatchError","highlight_start":1,"highlight_end":18},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        fn from (err : $ error < $ generic $ (, $ inst_generic) ? >) -> Self","highlight_start":1,"highlight_end":77},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            let index = < $ generic :: ModuleToIndex as $ crate :: traits ::","highlight_start":1,"highlight_end":77},{"text":"            ModuleToIndex > :: module_to_index :: < $ module < $ generic $","highlight_start":1,"highlight_end":75},{"text":"            (, $ inst_generic) ? >> () . expect","highlight_start":1,"highlight_end":48},{"text":"            (\"Every active module has an index in the runtime; qed\") as u8 ; $","highlight_start":1,"highlight_end":79},{"text":"            crate :: sp_runtime :: DispatchError :: Module","highlight_start":1,"highlight_end":59},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                index, error : err . as_u8 (), message : Some","highlight_start":1,"highlight_end":62},{"text":"                (err . as_str ()),","highlight_start":1,"highlight_end":35},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } impl < $ generic : $ trait $ (, $ inst_generic : $ instance) ? > $ crate","highlight_start":1,"highlight_end":79},{"text":"    :: error :: ModuleErrorMetadata for $ error < $ generic $","highlight_start":1,"highlight_end":62},{"text":"    (, $ inst_generic) ? >","highlight_start":1,"highlight_end":27},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        fn metadata () -> & 'static [$ crate :: error :: ErrorMetadata]","highlight_start":1,"highlight_end":72},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            &","highlight_start":1,"highlight_end":14},{"text":"            [$","highlight_start":1,"highlight_end":15},{"text":"             ($ crate :: error :: ErrorMetadata","highlight_start":1,"highlight_end":48},{"text":"              {","highlight_start":1,"highlight_end":16},{"text":"                  name : $ crate :: error :: DecodeDifferent :: Encode","highlight_start":1,"highlight_end":71},{"text":"                  (stringify ! ($ name)), documentation : $ crate :: error ::","highlight_start":1,"highlight_end":78},{"text":"                  DecodeDifferent :: Encode (& [$ ($ doc_attr), *]),","highlight_start":1,"highlight_end":69},{"text":"              }), *]","highlight_start":1,"highlight_end":21},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ GENERATE_AS_U8 $ self : ident $ error : ident { $ ($ generated : tt) * } $","highlight_start":1,"highlight_end":78},{"text":" index : expr, $ name : ident $ (, $ rest : ident) *) =>","highlight_start":1,"highlight_end":57},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: decl_error !","highlight_start":1,"highlight_end":28},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        @ GENERATE_AS_U8 $ self $ error","highlight_start":1,"highlight_end":40},{"text":"        { $ ($ generated) * $ error :: $ name => $ index, } $ index + 1, $","highlight_start":1,"highlight_end":75},{"text":"        ($ rest), *","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ GENERATE_AS_U8 $ self : ident $ error : ident { $ ($ generated : tt) * } $","highlight_start":1,"highlight_end":78},{"text":" index : expr,) =>","highlight_start":1,"highlight_end":19},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    match $ self","highlight_start":1,"highlight_end":17},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        $ error :: __Ignore (_, _) => unreachable !","highlight_start":1,"highlight_end":52},{"text":"        (\"`__Ignore` can never be constructed\"), $ ($ generated) *","highlight_start":1,"highlight_end":67},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":6058,"byte_end":6070,"line_start":187,"line_end":187,"column_start":37,"column_end":49,"is_primary":true,"text":[{"text":"\t\t\t\t\tNone => return Err(Error::<T>::InvalidState.into())","highlight_start":37,"highlight_end":49}],"label":"variant or associated item not found in `Error<T>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":6058,"byte_end":6070,"line_start":187,"line_end":187,"column_start":37,"column_end":49,"is_primary":true,"text":[{"text":"\t\t\t\t\tNone => return Err(Error::<T>::InvalidState.into())","highlight_start":37,"highlight_end":49}],"label":null,"suggested_replacement":"InvalidSender","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `InvalidState` found for enum `Error<T>` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:187:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                    None => return Err(Error::<T>::InvalidState.into())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `Error<T>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is a variant with a similar name: `InvalidSender`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m395\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdecl_error! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m396\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub enum Error for Module<T: Trait> {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m397\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        NotOwner,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m398\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        InvalidPlayerLength,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m406\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m407\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `InvalidState` not found here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"no field `seqNum` on type `StateProof<sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::MultiSignature>`","code":{"code":"E0609","explanation":"Attempted to access a non-existent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":6252,"byte_end":6258,"line_start":193,"line_end":193,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"\t\t\t\t\tseqNum: transaction.seqNum,","highlight_start":26,"highlight_end":32}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `appState`, `sigs`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0609]\u001b[0m\u001b[0m\u001b[1m: no field `seqNum` on type `StateProof<sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::MultiSignature>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:193:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    seqNum: transaction.seqNum,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munknown field\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: available fields are: `appState`, `sigs`\u001b[0m\n\n"}
{"message":"this function takes 3 parameters but 2 parameters were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":6506,"byte_end":6584,"line_start":200,"line_end":200,"column_start":5,"column_end":83,"is_primary":true,"text":[{"text":"\t\t\t\t<DocumentPermissionsState<T>>::mutate((&did, &access_condition.grantee), true);","highlight_start":5,"highlight_end":83}],"label":"expected 3 parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 3 parameters but 2 parameters were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:200:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                <DocumentPermissionsState<T>>::mutate((&did, &access_condition.grantee), true);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 3 parameters\u001b[0m\n\n"}
{"message":"expected a `std::ops::FnOnce<(&mut bool,)>` closure, found `bool`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":6635,"byte_end":6639,"line_start":201,"line_end":201,"column_start":50,"column_end":54,"is_primary":true,"text":[{"text":"\t\t\t\t<FinalizedOf<T>>::mutate(&condition_address, true);","highlight_start":50,"highlight_end":54}],"label":"expected an `FnOnce<(&mut bool,)>` closure, found `bool`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::ops::FnOnce<(&mut bool,)>` is not implemented for `bool`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by `sp_api_hidden_includes_decl_storage::hidden_include::StorageMap::mutate`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: expected a `std::ops::FnOnce<(&mut bool,)>` closure, found `bool`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:201:50\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m201\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                <FinalizedOf<T>>::mutate(&condition_address, true);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected an `FnOnce<(&mut bool,)>` closure, found `bool`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `std::ops::FnOnce<(&mut bool,)>` is not implemented for `bool`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required by `sp_api_hidden_includes_decl_storage::hidden_include::StorageMap::mutate`\u001b[0m\n\n"}
{"message":"expected a `std::ops::FnOnce<(&mut bool,)>` closure, found `bool`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":6689,"byte_end":6693,"line_start":202,"line_end":202,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"\t\t\t\t<OutcomeOf<T>>::mutate(&condition_address, true);","highlight_start":48,"highlight_end":52}],"label":"expected an `FnOnce<(&mut bool,)>` closure, found `bool`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::ops::FnOnce<(&mut bool,)>` is not implemented for `bool`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by `sp_api_hidden_includes_decl_storage::hidden_include::StorageMap::mutate`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: expected a `std::ops::FnOnce<(&mut bool,)>` closure, found `bool`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:202:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                <OutcomeOf<T>>::mutate(&condition_address, true);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected an `FnOnce<(&mut bool,)>` closure, found `bool`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `std::ops::FnOnce<(&mut bool,)>` is not implemented for `bool`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required by `sp_api_hidden_includes_decl_storage::hidden_include::StorageMap::mutate`\u001b[0m\n\n"}
{"message":"no function or associated item named `boolean_owner` found for struct `pallet_did::Module<T>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":9218,"byte_end":9231,"line_start":312,"line_end":312,"column_start":42,"column_end":55,"is_primary":true,"text":[{"text":"\t\t\tlet isOwner: bool = <did::Module<T>>::boolean_owner(&did, &who);","highlight_start":42,"highlight_end":55}],"label":"function or associated item not found in `pallet_did::Module<T>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the method `boolean_owner` exists but the following trait bounds were not satisfied:\n`T : pallet_did::Trait`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no function or associated item named `boolean_owner` found for struct `pallet_did::Module<T>` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:312:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m312\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let isOwner: bool = <did::Module<T>>::boolean_owner(&did, &who);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfunction or associated item not found in `pallet_did::Module<T>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the method `boolean_owner` exists but the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `T : pallet_did::Trait`\u001b[0m\n\n"}
{"message":"the trait bound `T: pallet_did::Trait` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":9201,"byte_end":9215,"line_start":312,"line_end":312,"column_start":25,"column_end":39,"is_primary":true,"text":[{"text":"\t\t\tlet isOwner: bool = <did::Module<T>>::boolean_owner(&did, &who);","highlight_start":25,"highlight_end":39}],"label":"the trait `pallet_did::Trait` is not implemented for `T`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2453,"byte_end":2454,"line_start":79,"line_end":79,"column_start":20,"column_end":21,"is_primary":false,"text":[{"text":"\tpub struct Module<T: Trait> for enum Call where origin: T::Origin {","highlight_start":20,"highlight_end":21}],"label":"consider adding a `where T: pallet_did::Trait` bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by `pallet_did::Module`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `T: pallet_did::Trait` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:312:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub struct Module<T: Trait> for enum Call where origin: T::Origin {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider adding a `where T: pallet_did::Trait` bound\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m312\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let isOwner: bool = <did::Module<T>>::boolean_owner(&did, &who);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `pallet_did::Trait` is not implemented for `T`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required by `pallet_did::Module`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":9322,"byte_end":9478,"line_start":315,"line_end":323,"column_start":26,"column_end":5,"is_primary":true,"text":[{"text":"\t\t\tlet mut didKey: u32 = |_didKey| {","highlight_start":26,"highlight_end":37},{"text":"\t\t\t\tlet mut _didKey = Self::did_key();","highlight_start":1,"highlight_end":39},{"text":"\t\t\t\tif _didKey == 0 || _didKey == 1 {","highlight_start":1,"highlight_end":38},{"text":"\t\t\t\t\t_didKey = 2;","highlight_start":1,"highlight_end":18},{"text":"\t\t\t\t\t_didKey","highlight_start":1,"highlight_end":13},{"text":"\t\t\t\t} else {","highlight_start":1,"highlight_end":13},{"text":"\t\t\t\t\t_didKey","highlight_start":1,"highlight_end":13},{"text":"\t\t\t\t}","highlight_start":1,"highlight_end":6},{"text":"\t\t\t};","highlight_start":1,"highlight_end":5}],"label":"expected `u32`, found closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":9316,"byte_end":9319,"line_start":315,"line_end":315,"column_start":20,"column_end":23,"is_primary":false,"text":[{"text":"\t\t\tlet mut didKey: u32 = |_didKey| {","highlight_start":20,"highlight_end":23}],"label":"expected due to this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type `u32`\nfound closure `[closure@src/lib.rs:315:26: 323:5]`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:315:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m315\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m            let mut didKey: u32 = |_didKey| {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m_____________________________\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m___^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected due to this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m316\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let mut _didKey = Self::did_key();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m317\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if _didKey == 0 || _didKey == 1 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m318\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    _didKey = 2;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m322\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found closure\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type `\u001b[0m\u001b[0m\u001b[1mu32\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m            found closure `\u001b[0m\u001b[0m\u001b[1m[closure@src/lib.rs:315:26: 323:5]\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":11290,"byte_end":11301,"line_start":415,"line_end":415,"column_start":33,"column_end":44,"is_primary":true,"text":[{"text":"\t\tif &signatures[0].verify(msg, &signers[0]) && &signatures[1].verify(msg, &signers[1]) {","highlight_start":33,"highlight_end":44}],"label":"expected struct `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`, found associated type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`\n   found reference `&<T as frame_system::Trait>::AccountId`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider constraining the associated type `<T as frame_system::Trait>::AccountId` to `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:415:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m415\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if &signatures[0].verify(msg, &signers[0]) && &signatures[1].verify(msg, &signers[1]) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected struct `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`, found associated type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected reference `\u001b[0m\u001b[0m\u001b[1m&sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m               found reference `\u001b[0m\u001b[0m\u001b[1m&<T as frame_system::Trait>::AccountId\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider constraining the associated type `<T as frame_system::Trait>::AccountId` to `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":11263,"byte_end":11302,"line_start":415,"line_end":415,"column_start":6,"column_end":45,"is_primary":true,"text":[{"text":"\t\tif &signatures[0].verify(msg, &signers[0]) && &signatures[1].verify(msg, &signers[1]) {","highlight_start":6,"highlight_end":45}],"label":"expected `bool`, found `&bool`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider removing the borrow","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":11263,"byte_end":11302,"line_start":415,"line_end":415,"column_start":6,"column_end":45,"is_primary":true,"text":[{"text":"\t\tif &signatures[0].verify(msg, &signers[0]) && &signatures[1].verify(msg, &signers[1]) {","highlight_start":6,"highlight_end":45}],"label":null,"suggested_replacement":"signatures[0].verify(msg, &signers[0])","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:415:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m415\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if &signatures[0].verify(msg, &signers[0]) && &signatures[1].verify(msg, &signers[1]) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `bool`, found `&bool`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: consider removing the borrow: `signatures[0].verify(msg, &signers[0])`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":11333,"byte_end":11344,"line_start":415,"line_end":415,"column_start":76,"column_end":87,"is_primary":true,"text":[{"text":"\t\tif &signatures[0].verify(msg, &signers[0]) && &signatures[1].verify(msg, &signers[1]) {","highlight_start":76,"highlight_end":87}],"label":"expected struct `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`, found associated type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`\n   found reference `&<T as frame_system::Trait>::AccountId`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider constraining the associated type `<T as frame_system::Trait>::AccountId` to `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:415:76\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m415\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if &signatures[0].verify(msg, &signers[0]) && &signatures[1].verify(msg, &signers[1]) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected struct `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`, found associated type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected reference `\u001b[0m\u001b[0m\u001b[1m&sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m               found reference `\u001b[0m\u001b[0m\u001b[1m&<T as frame_system::Trait>::AccountId\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider constraining the associated type `<T as frame_system::Trait>::AccountId` to `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":11306,"byte_end":11345,"line_start":415,"line_end":415,"column_start":49,"column_end":88,"is_primary":true,"text":[{"text":"\t\tif &signatures[0].verify(msg, &signers[0]) && &signatures[1].verify(msg, &signers[1]) {","highlight_start":49,"highlight_end":88}],"label":"expected `bool`, found `&bool`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider removing the borrow","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":11306,"byte_end":11345,"line_start":415,"line_end":415,"column_start":49,"column_end":88,"is_primary":true,"text":[{"text":"\t\tif &signatures[0].verify(msg, &signers[0]) && &signatures[1].verify(msg, &signers[1]) {","highlight_start":49,"highlight_end":88}],"label":null,"suggested_replacement":"signatures[1].verify(msg, &signers[1])","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:415:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m415\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if &signatures[0].verify(msg, &signers[0]) && &signatures[1].verify(msg, &signers[1]) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `bool`, found `&bool`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: consider removing the borrow: `signatures[1].verify(msg, &signers[1])`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":11397,"byte_end":11408,"line_start":417,"line_end":417,"column_start":40,"column_end":51,"is_primary":true,"text":[{"text":"\t\t} else if &signatures[1].verify(msg, &signers[1]) && &signatures[0].verify(msg, &signers[0]) {","highlight_start":40,"highlight_end":51}],"label":"expected struct `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`, found associated type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`\n   found reference `&<T as frame_system::Trait>::AccountId`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider constraining the associated type `<T as frame_system::Trait>::AccountId` to `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:417:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m417\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        } else if &signatures[1].verify(msg, &signers[1]) && &signatures[0].verify(msg, &signers[0]) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected struct `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`, found associated type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected reference `\u001b[0m\u001b[0m\u001b[1m&sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m               found reference `\u001b[0m\u001b[0m\u001b[1m&<T as frame_system::Trait>::AccountId\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider constraining the associated type `<T as frame_system::Trait>::AccountId` to `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":11370,"byte_end":11409,"line_start":417,"line_end":417,"column_start":13,"column_end":52,"is_primary":true,"text":[{"text":"\t\t} else if &signatures[1].verify(msg, &signers[1]) && &signatures[0].verify(msg, &signers[0]) {","highlight_start":13,"highlight_end":52}],"label":"expected `bool`, found `&bool`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider removing the borrow","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":11370,"byte_end":11409,"line_start":417,"line_end":417,"column_start":13,"column_end":52,"is_primary":true,"text":[{"text":"\t\t} else if &signatures[1].verify(msg, &signers[1]) && &signatures[0].verify(msg, &signers[0]) {","highlight_start":13,"highlight_end":52}],"label":null,"suggested_replacement":"signatures[1].verify(msg, &signers[1])","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:417:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m417\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        } else if &signatures[1].verify(msg, &signers[1]) && &signatures[0].verify(msg, &signers[0]) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `bool`, found `&bool`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: consider removing the borrow: `signatures[1].verify(msg, &signers[1])`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":11440,"byte_end":11451,"line_start":417,"line_end":417,"column_start":83,"column_end":94,"is_primary":true,"text":[{"text":"\t\t} else if &signatures[1].verify(msg, &signers[1]) && &signatures[0].verify(msg, &signers[0]) {","highlight_start":83,"highlight_end":94}],"label":"expected struct `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`, found associated type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`\n   found reference `&<T as frame_system::Trait>::AccountId`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider constraining the associated type `<T as frame_system::Trait>::AccountId` to `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:417:83\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m417\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        } else if &signatures[1].verify(msg, &signers[1]) && &signatures[0].verify(msg, &signers[0]) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected struct `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`, found associated type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected reference `\u001b[0m\u001b[0m\u001b[1m&sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m               found reference `\u001b[0m\u001b[0m\u001b[1m&<T as frame_system::Trait>::AccountId\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider constraining the associated type `<T as frame_system::Trait>::AccountId` to `sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::AccountId32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":11413,"byte_end":11452,"line_start":417,"line_end":417,"column_start":56,"column_end":95,"is_primary":true,"text":[{"text":"\t\t} else if &signatures[1].verify(msg, &signers[1]) && &signatures[0].verify(msg, &signers[0]) {","highlight_start":56,"highlight_end":95}],"label":"expected `bool`, found `&bool`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider removing the borrow","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":11413,"byte_end":11452,"line_start":417,"line_end":417,"column_start":56,"column_end":95,"is_primary":true,"text":[{"text":"\t\t} else if &signatures[1].verify(msg, &signers[1]) && &signatures[0].verify(msg, &signers[0]) {","highlight_start":56,"highlight_end":95}],"label":null,"suggested_replacement":"signatures[0].verify(msg, &signers[0])","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:417:56\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m417\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        } else if &signatures[1].verify(msg, &signers[1]) && &signatures[0].verify(msg, &signers[0]) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `bool`, found `&bool`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: consider removing the borrow: `signatures[0].verify(msg, &signers[0])`\u001b[0m\n\n"}
{"message":"the trait bound `u32: _::_parity_scale_codec::EncodeLike<<T as frame_system::Trait>::AccountId>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":12196,"byte_end":12217,"line_start":448,"line_end":448,"column_start":3,"column_end":24,"is_primary":true,"text":[{"text":"\t\t<KeyOfDID<T>>::insert(_key, &did);","highlight_start":3,"highlight_end":24}],"label":"the trait `_::_parity_scale_codec::EncodeLike<<T as frame_system::Trait>::AccountId>` is not implemented for `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by `sp_api_hidden_includes_decl_storage::hidden_include::StorageMap::insert`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u32: _::_parity_scale_codec::EncodeLike<<T as frame_system::Trait>::AccountId>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:448:3\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m448\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        <KeyOfDID<T>>::insert(_key, &did);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `_::_parity_scale_codec::EncodeLike<<T as frame_system::Trait>::AccountId>` is not implemented for `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required by `sp_api_hidden_includes_decl_storage::hidden_include::StorageMap::insert`\u001b[0m\n\n"}
{"message":"the trait bound `&<T as frame_system::Trait>::AccountId: _::_parity_scale_codec::EncodeLike<u32>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":12224,"byte_end":12228,"line_start":448,"line_end":448,"column_start":31,"column_end":35,"is_primary":true,"text":[{"text":"\t\t<KeyOfDID<T>>::insert(_key, &did);","highlight_start":31,"highlight_end":35}],"label":"the trait `_::_parity_scale_codec::EncodeLike<u32>` is not implemented for `&<T as frame_system::Trait>::AccountId`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by `sp_api_hidden_includes_decl_storage::hidden_include::StorageMap::insert`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider removing 1 leading `&`-references","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":12224,"byte_end":12225,"line_start":448,"line_end":448,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"\t\t<KeyOfDID<T>>::insert(_key, &did);","highlight_start":31,"highlight_end":32}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `&<T as frame_system::Trait>::AccountId: _::_parity_scale_codec::EncodeLike<u32>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:448:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m448\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        <KeyOfDID<T>>::insert(_key, &did);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `_::_parity_scale_codec::EncodeLike<u32>` is not implemented for `&<T as frame_system::Trait>::AccountId`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: consider removing 1 leading `&`-references\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required by `sp_api_hidden_includes_decl_storage::hidden_include::StorageMap::insert`\u001b[0m\n\n"}
{"message":"no variant or associated item named `DIDKey` found for enum `RawEvent<_, _>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n"},"level":"error","spans":[{"file_name":"<::frame_support::event::__decl_generic_event macros>","byte_start":3843,"byte_end":4075,"line_start":86,"line_end":92,"column_start":23,"column_end":6,"is_primary":false,"text":[{"text":"     $ (# [$ attr]) * pub enum RawEvent < $ ($ generic_param), * $","highlight_start":23,"highlight_end":67},{"text":"    (, $ instance) ? >","highlight_start":1,"highlight_end":23},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        $ ($ events) * $","highlight_start":1,"highlight_end":25},{"text":"        (# [doc (hidden)] # [codec (skip)] PhantomData","highlight_start":1,"highlight_end":55},{"text":"         ($ crate :: sp_std :: marker :: PhantomData < $ instance >),) ?","highlight_start":1,"highlight_end":73},{"text":"    } impl < $ ($ generic_param), * $ (, $ instance) ? > From < RawEvent < $","highlight_start":1,"highlight_end":6}],"label":"variant or associated item `DIDKey` not found here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::frame_support::event::__decl_generic_event macros>","byte_start":644,"byte_end":923,"line_start":17,"line_end":23,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    $ crate :: __decl_generic_event !","highlight_start":5,"highlight_end":38},{"text":"    (@ generate $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":61},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ events) * } ;","highlight_start":1,"highlight_end":76},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         $ ($ parsed) *, $ trait_type = < $ generic as $ trait > :: $","highlight_start":1,"highlight_end":70},{"text":"         trait_type","highlight_start":1,"highlight_end":20},{"text":"     } ;) ;","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::frame_support::event::__decl_generic_event macros>","byte_start":2222,"byte_end":2505,"line_start":54,"line_end":60,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    $ crate :: __decl_generic_event !","highlight_start":5,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ rest) * } ;","highlight_start":1,"highlight_end":74},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         $ ($ parsed) *, $ trait_type = < $ generic as $ trait > :: $","highlight_start":1,"highlight_end":70},{"text":"         trait_type","highlight_start":1,"highlight_end":20},{"text":"     } ;) ;","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::frame_support::event::__decl_generic_event macros>","byte_start":160,"byte_end":345,"line_start":5,"line_end":8,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    $ crate :: __decl_generic_event !","highlight_start":5,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ tt) * } ; { } ;)","highlight_start":1,"highlight_end":79},{"text":"    ;","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::frame_support::event::decl_event macros>","byte_start":205,"byte_end":361,"line_start":5,"line_end":7,"column_start":5,"column_end":75,"is_primary":false,"text":[{"text":"    $ crate :: __decl_generic_event !","highlight_start":5,"highlight_end":38},{"text":"    ($ (# [$ attr]) * ; $ evt_generic_param ; $","highlight_start":1,"highlight_end":48},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ tt) * } ;) ;","highlight_start":1,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10311,"byte_end":10890,"line_start":373,"line_end":393,"column_start":1,"column_end":3,"is_primary":false,"text":[{"text":"decl_event!(","highlight_start":1,"highlight_end":13},{"text":"\tpub enum Event<T>","highlight_start":1,"highlight_end":19},{"text":"\twhere","highlight_start":1,"highlight_end":7},{"text":"\t<T as frame_system::Trait>::AccountId,","highlight_start":1,"highlight_end":40},{"text":"\t<T as frame_system::Trait>::BlockNumber,","highlight_start":1,"highlight_end":42},{"text":"\t{","highlight_start":1,"highlight_end":3},{"text":"\t\tAccessConditionCreated(AccountId, AccountId, AccountId, u32),","highlight_start":1,"highlight_end":64},{"text":"\t\tSwapPosition(AccountId, BlockNumber),","highlight_start":1,"highlight_end":40},{"text":"\t\tSetIdle(AccountId, BlockNumber),","highlight_start":1,"highlight_end":35},{"text":"\t\tIntendSettle(AccountId, BlockNumber),","highlight_start":1,"highlight_end":40},{"text":"\t\tIdleStatus(AccountId, BlockNumber),","highlight_start":1,"highlight_end":38},{"text":"\t\tFinalizedStatus(AccountId, BlockNumber),","highlight_start":1,"highlight_end":43},{"text":"\t\tSeqNum(u32, BlockNumber),","highlight_start":1,"highlight_end":28},{"text":"\t\tOwner(AccountId, BlockNumber),","highlight_start":1,"highlight_end":33},{"text":"\t\tGrantee(AccountId, BlockNumber),","highlight_start":1,"highlight_end":35},{"text":"\t\tBooleanOutcome(bool),","highlight_start":1,"highlight_end":24},{"text":"\t\tAccessPermission(bool),","highlight_start":1,"highlight_end":26},{"text":"\t\tNewDID(AccountId, u32),","highlight_start":1,"highlight_end":26},{"text":"\t\tDID(AccountId),","highlight_start":1,"highlight_end":18},{"text":"\t}","highlight_start":1,"highlight_end":3},{"text":");","highlight_start":1,"highlight_end":3}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"decl_event!","def_site_span":{"file_name":"<::frame_support::event::decl_event macros>","byte_start":0,"byte_end":944,"line_start":1,"line_end":22,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * pub enum Event < $ evt_generic_param : ident $","highlight_start":1,"highlight_end":72},{"text":" (, $ instance : ident $ (: $ instantiable : ident) ? $","highlight_start":1,"highlight_end":56},{"text":"  (= $ event_default_instance : path) ?) ? > where $ ($ tt : tt) *) =>","highlight_start":1,"highlight_end":71},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    ($ (# [$ attr]) * ; $ evt_generic_param ; $","highlight_start":1,"highlight_end":48},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ tt) * } ;) ;","highlight_start":1,"highlight_end":75},{"text":"} ; ($ (# [$ attr : meta]) * pub enum Event { $ ($ events : tt) * }) =>","highlight_start":1,"highlight_end":72},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    #","highlight_start":1,"highlight_end":6},{"text":"    [derive","highlight_start":1,"highlight_end":12},{"text":"     (Clone, PartialEq, Eq, $ crate :: codec :: Encode, $ crate :: codec ::","highlight_start":1,"highlight_end":76},{"text":"      Decode, $ crate :: RuntimeDebug,)] /// Events for this module.","highlight_start":1,"highlight_end":69},{"text":"     ///","highlight_start":1,"highlight_end":9},{"text":"     $ (# [$ attr]) * pub enum Event { $ ($ events) * } impl From < Event >","highlight_start":1,"highlight_end":76},{"text":"    for () { fn from (_ : Event) -> () { () } } impl Event","highlight_start":1,"highlight_end":59},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        # [allow (dead_code)] # [doc (hidden)] pub fn metadata () -> & 'static","highlight_start":1,"highlight_end":79},{"text":"        [$ crate :: event :: EventMetadata]","highlight_start":1,"highlight_end":44},{"text":"        { $ crate :: __events_to_metadata ! (; $ ($ events) *) }","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::__decl_generic_event!","def_site_span":{"file_name":"<::frame_support::event::__decl_generic_event macros>","byte_start":0,"byte_end":4819,"line_start":1,"line_end":111,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":61},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ ($ tt : tt) * } ;) =>","highlight_start":1,"highlight_end":27},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ tt) * } ; { } ;)","highlight_start":1,"highlight_end":79},{"text":"    ;","highlight_start":1,"highlight_end":6},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     < $ generic : ident as $ trait : path > :: $ trait_type : ident $ (,) ?","highlight_start":1,"highlight_end":77},{"text":"     { $ ($ events : tt) * }","highlight_start":1,"highlight_end":29},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ generate $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":61},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ events) * } ;","highlight_start":1,"highlight_end":76},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         $ ($ parsed) *, $ trait_type = < $ generic as $ trait > :: $","highlight_start":1,"highlight_end":70},{"text":"         trait_type","highlight_start":1,"highlight_end":20},{"text":"     } ;) ;","highlight_start":1,"highlight_end":12},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     $ generic_rename : ident = $ generic_type : ty $ (,) ?","highlight_start":1,"highlight_end":60},{"text":"     { $ ($ events : tt) * }","highlight_start":1,"highlight_end":29},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ generate $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":61},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ events) * } ;","highlight_start":1,"highlight_end":76},{"text":"     { $ ($ parsed) *, $ generic_rename = $ generic_type } ;) ;","highlight_start":1,"highlight_end":64},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_rename : ident = $ generic_type : ty, $ ($ rest : tt) * } ;","highlight_start":1,"highlight_end":73},{"text":" { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":31},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ rest) * } ;","highlight_start":1,"highlight_end":74},{"text":"     { $ ($ parsed) *, $ generic_rename = $ generic_type } ;) ;","highlight_start":1,"highlight_end":64},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     < $ generic : ident as $ trait : path > :: $ trait_type : ident, $","highlight_start":1,"highlight_end":72},{"text":"     ($ rest : tt) *","highlight_start":1,"highlight_end":21},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ rest) * } ;","highlight_start":1,"highlight_end":74},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         $ ($ parsed) *, $ trait_type = < $ generic as $ trait > :: $","highlight_start":1,"highlight_end":70},{"text":"         trait_type","highlight_start":1,"highlight_end":20},{"text":"     } ;) ;","highlight_start":1,"highlight_end":12},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_type : ty, $ ($ rest : tt) * } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":76},{"text":"{ $ crate :: __decl_generic_event ! (@ cannot_parse $ generic_type) ; } ;","highlight_start":1,"highlight_end":74},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_type : ty { $ ($ events : tt) * } } ; { $ ($ parsed : tt) * } ;)","highlight_start":1,"highlight_end":78},{"text":"=> { $ crate :: __decl_generic_event ! (@ cannot_parse $ generic_type) ; } ;","highlight_start":1,"highlight_end":77},{"text":"(@ generate $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":72},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ ($ events : tt) * } ;","highlight_start":1,"highlight_end":27},{"text":" { , $ ($ generic_param : ident = $ generic_type : ty), * } ;) =>","highlight_start":1,"highlight_end":66},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    /// [`RawEvent`] specialized for the configuration [`Trait`]","highlight_start":1,"highlight_end":65},{"text":"     ///","highlight_start":1,"highlight_end":9},{"text":"     /// [`RawEvent`]: enum.RawEvent.html","highlight_start":1,"highlight_end":42},{"text":"     /// [`Trait`]: trait.Trait.html","highlight_start":1,"highlight_end":37},{"text":"     pub type Event < $ event_generic_param $","highlight_start":1,"highlight_end":46},{"text":"    (, $ instance $ (= $ event_default_instance) ?) ? > = RawEvent < $","highlight_start":1,"highlight_end":71},{"text":"    ($ generic_type), * $ (, $ instance) ? > ; #","highlight_start":1,"highlight_end":49},{"text":"    [derive","highlight_start":1,"highlight_end":12},{"text":"     (Clone, PartialEq, Eq, $ crate :: codec :: Encode, $ crate :: codec ::","highlight_start":1,"highlight_end":76},{"text":"      Decode, $ crate :: RuntimeDebug,)] /// Events for this module.","highlight_start":1,"highlight_end":69},{"text":"     ///","highlight_start":1,"highlight_end":9},{"text":"     $ (# [$ attr]) * pub enum RawEvent < $ ($ generic_param), * $","highlight_start":1,"highlight_end":67},{"text":"    (, $ instance) ? >","highlight_start":1,"highlight_end":23},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        $ ($ events) * $","highlight_start":1,"highlight_end":25},{"text":"        (# [doc (hidden)] # [codec (skip)] PhantomData","highlight_start":1,"highlight_end":55},{"text":"         ($ crate :: sp_std :: marker :: PhantomData < $ instance >),) ?","highlight_start":1,"highlight_end":73},{"text":"    } impl < $ ($ generic_param), * $ (, $ instance) ? > From < RawEvent < $","highlight_start":1,"highlight_end":77},{"text":"    ($ generic_param), * $ (, $ instance) ? >> for ()","highlight_start":1,"highlight_end":54},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        fn from (_ : RawEvent < $ ($ generic_param), * $ (, $ instance) ? >)","highlight_start":1,"highlight_end":77},{"text":"        -> () { () }","highlight_start":1,"highlight_end":21},{"text":"    } impl < $ ($ generic_param), * $ (, $ instance) ? > RawEvent < $","highlight_start":1,"highlight_end":70},{"text":"    ($ generic_param), * $ (, $ instance) ? >","highlight_start":1,"highlight_end":46},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        # [allow (dead_code)] pub fn metadata () -> & 'static","highlight_start":1,"highlight_end":62},{"text":"        [$ crate :: event :: EventMetadata]","highlight_start":1,"highlight_end":44},{"text":"        { $ crate :: __events_to_metadata ! (; $ ($ events) *) }","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"} ; (@ cannot_parse $ ty : ty) =>","highlight_start":1,"highlight_end":34},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    compile_error !","highlight_start":1,"highlight_end":20},{"text":"    (concat !","highlight_start":1,"highlight_end":14},{"text":"     (\"The type `\", stringify ! ($ ty),","highlight_start":1,"highlight_end":40},{"text":"      \"` can't be parsed as an unnamed one, please name it `Name = \",","highlight_start":1,"highlight_end":70},{"text":"      stringify ! ($ ty), \"`\")) ;","highlight_start":1,"highlight_end":34},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::__decl_generic_event!","def_site_span":{"file_name":"<::frame_support::event::__decl_generic_event macros>","byte_start":0,"byte_end":4819,"line_start":1,"line_end":111,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":61},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ ($ tt : tt) * } ;) =>","highlight_start":1,"highlight_end":27},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ tt) * } ; { } ;)","highlight_start":1,"highlight_end":79},{"text":"    ;","highlight_start":1,"highlight_end":6},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     < $ generic : ident as $ trait : path > :: $ trait_type : ident $ (,) ?","highlight_start":1,"highlight_end":77},{"text":"     { $ ($ events : tt) * }","highlight_start":1,"highlight_end":29},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ generate $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":61},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ events) * } ;","highlight_start":1,"highlight_end":76},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         $ ($ parsed) *, $ trait_type = < $ generic as $ trait > :: $","highlight_start":1,"highlight_end":70},{"text":"         trait_type","highlight_start":1,"highlight_end":20},{"text":"     } ;) ;","highlight_start":1,"highlight_end":12},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     $ generic_rename : ident = $ generic_type : ty $ (,) ?","highlight_start":1,"highlight_end":60},{"text":"     { $ ($ events : tt) * }","highlight_start":1,"highlight_end":29},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ generate $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":61},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ events) * } ;","highlight_start":1,"highlight_end":76},{"text":"     { $ ($ parsed) *, $ generic_rename = $ generic_type } ;) ;","highlight_start":1,"highlight_end":64},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_rename : ident = $ generic_type : ty, $ ($ rest : tt) * } ;","highlight_start":1,"highlight_end":73},{"text":" { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":31},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ rest) * } ;","highlight_start":1,"highlight_end":74},{"text":"     { $ ($ parsed) *, $ generic_rename = $ generic_type } ;) ;","highlight_start":1,"highlight_end":64},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     < $ generic : ident as $ trait : path > :: $ trait_type : ident, $","highlight_start":1,"highlight_end":72},{"text":"     ($ rest : tt) *","highlight_start":1,"highlight_end":21},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ rest) * } ;","highlight_start":1,"highlight_end":74},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         $ ($ parsed) *, $ trait_type = < $ generic as $ trait > :: $","highlight_start":1,"highlight_end":70},{"text":"         trait_type","highlight_start":1,"highlight_end":20},{"text":"     } ;) ;","highlight_start":1,"highlight_end":12},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_type : ty, $ ($ rest : tt) * } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":76},{"text":"{ $ crate :: __decl_generic_event ! (@ cannot_parse $ generic_type) ; } ;","highlight_start":1,"highlight_end":74},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_type : ty { $ ($ events : tt) * } } ; { $ ($ parsed : tt) * } ;)","highlight_start":1,"highlight_end":78},{"text":"=> { $ crate :: __decl_generic_event ! (@ cannot_parse $ generic_type) ; } ;","highlight_start":1,"highlight_end":77},{"text":"(@ generate $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":72},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ ($ events : tt) * } ;","highlight_start":1,"highlight_end":27},{"text":" { , $ ($ generic_param : ident = $ generic_type : ty), * } ;) =>","highlight_start":1,"highlight_end":66},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    /// [`RawEvent`] specialized for the configuration [`Trait`]","highlight_start":1,"highlight_end":65},{"text":"     ///","highlight_start":1,"highlight_end":9},{"text":"     /// [`RawEvent`]: enum.RawEvent.html","highlight_start":1,"highlight_end":42},{"text":"     /// [`Trait`]: trait.Trait.html","highlight_start":1,"highlight_end":37},{"text":"     pub type Event < $ event_generic_param $","highlight_start":1,"highlight_end":46},{"text":"    (, $ instance $ (= $ event_default_instance) ?) ? > = RawEvent < $","highlight_start":1,"highlight_end":71},{"text":"    ($ generic_type), * $ (, $ instance) ? > ; #","highlight_start":1,"highlight_end":49},{"text":"    [derive","highlight_start":1,"highlight_end":12},{"text":"     (Clone, PartialEq, Eq, $ crate :: codec :: Encode, $ crate :: codec ::","highlight_start":1,"highlight_end":76},{"text":"      Decode, $ crate :: RuntimeDebug,)] /// Events for this module.","highlight_start":1,"highlight_end":69},{"text":"     ///","highlight_start":1,"highlight_end":9},{"text":"     $ (# [$ attr]) * pub enum RawEvent < $ ($ generic_param), * $","highlight_start":1,"highlight_end":67},{"text":"    (, $ instance) ? >","highlight_start":1,"highlight_end":23},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        $ ($ events) * $","highlight_start":1,"highlight_end":25},{"text":"        (# [doc (hidden)] # [codec (skip)] PhantomData","highlight_start":1,"highlight_end":55},{"text":"         ($ crate :: sp_std :: marker :: PhantomData < $ instance >),) ?","highlight_start":1,"highlight_end":73},{"text":"    } impl < $ ($ generic_param), * $ (, $ instance) ? > From < RawEvent < $","highlight_start":1,"highlight_end":77},{"text":"    ($ generic_param), * $ (, $ instance) ? >> for ()","highlight_start":1,"highlight_end":54},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        fn from (_ : RawEvent < $ ($ generic_param), * $ (, $ instance) ? >)","highlight_start":1,"highlight_end":77},{"text":"        -> () { () }","highlight_start":1,"highlight_end":21},{"text":"    } impl < $ ($ generic_param), * $ (, $ instance) ? > RawEvent < $","highlight_start":1,"highlight_end":70},{"text":"    ($ generic_param), * $ (, $ instance) ? >","highlight_start":1,"highlight_end":46},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        # [allow (dead_code)] pub fn metadata () -> & 'static","highlight_start":1,"highlight_end":62},{"text":"        [$ crate :: event :: EventMetadata]","highlight_start":1,"highlight_end":44},{"text":"        { $ crate :: __events_to_metadata ! (; $ ($ events) *) }","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"} ; (@ cannot_parse $ ty : ty) =>","highlight_start":1,"highlight_end":34},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    compile_error !","highlight_start":1,"highlight_end":20},{"text":"    (concat !","highlight_start":1,"highlight_end":14},{"text":"     (\"The type `\", stringify ! ($ ty),","highlight_start":1,"highlight_end":40},{"text":"      \"` can't be parsed as an unnamed one, please name it `Name = \",","highlight_start":1,"highlight_end":70},{"text":"      stringify ! ($ ty), \"`\")) ;","highlight_start":1,"highlight_end":34},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::__decl_generic_event!","def_site_span":{"file_name":"<::frame_support::event::__decl_generic_event macros>","byte_start":0,"byte_end":4819,"line_start":1,"line_end":111,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":61},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ ($ tt : tt) * } ;) =>","highlight_start":1,"highlight_end":27},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ tt) * } ; { } ;)","highlight_start":1,"highlight_end":79},{"text":"    ;","highlight_start":1,"highlight_end":6},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     < $ generic : ident as $ trait : path > :: $ trait_type : ident $ (,) ?","highlight_start":1,"highlight_end":77},{"text":"     { $ ($ events : tt) * }","highlight_start":1,"highlight_end":29},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ generate $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":61},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ events) * } ;","highlight_start":1,"highlight_end":76},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         $ ($ parsed) *, $ trait_type = < $ generic as $ trait > :: $","highlight_start":1,"highlight_end":70},{"text":"         trait_type","highlight_start":1,"highlight_end":20},{"text":"     } ;) ;","highlight_start":1,"highlight_end":12},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     $ generic_rename : ident = $ generic_type : ty $ (,) ?","highlight_start":1,"highlight_end":60},{"text":"     { $ ($ events : tt) * }","highlight_start":1,"highlight_end":29},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ generate $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":61},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ events) * } ;","highlight_start":1,"highlight_end":76},{"text":"     { $ ($ parsed) *, $ generic_rename = $ generic_type } ;) ;","highlight_start":1,"highlight_end":64},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_rename : ident = $ generic_type : ty, $ ($ rest : tt) * } ;","highlight_start":1,"highlight_end":73},{"text":" { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":31},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ rest) * } ;","highlight_start":1,"highlight_end":74},{"text":"     { $ ($ parsed) *, $ generic_rename = $ generic_type } ;) ;","highlight_start":1,"highlight_end":64},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     < $ generic : ident as $ trait : path > :: $ trait_type : ident, $","highlight_start":1,"highlight_end":72},{"text":"     ($ rest : tt) *","highlight_start":1,"highlight_end":21},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ rest) * } ;","highlight_start":1,"highlight_end":74},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         $ ($ parsed) *, $ trait_type = < $ generic as $ trait > :: $","highlight_start":1,"highlight_end":70},{"text":"         trait_type","highlight_start":1,"highlight_end":20},{"text":"     } ;) ;","highlight_start":1,"highlight_end":12},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_type : ty, $ ($ rest : tt) * } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":76},{"text":"{ $ crate :: __decl_generic_event ! (@ cannot_parse $ generic_type) ; } ;","highlight_start":1,"highlight_end":74},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_type : ty { $ ($ events : tt) * } } ; { $ ($ parsed : tt) * } ;)","highlight_start":1,"highlight_end":78},{"text":"=> { $ crate :: __decl_generic_event ! (@ cannot_parse $ generic_type) ; } ;","highlight_start":1,"highlight_end":77},{"text":"(@ generate $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":72},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ ($ events : tt) * } ;","highlight_start":1,"highlight_end":27},{"text":" { , $ ($ generic_param : ident = $ generic_type : ty), * } ;) =>","highlight_start":1,"highlight_end":66},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    /// [`RawEvent`] specialized for the configuration [`Trait`]","highlight_start":1,"highlight_end":65},{"text":"     ///","highlight_start":1,"highlight_end":9},{"text":"     /// [`RawEvent`]: enum.RawEvent.html","highlight_start":1,"highlight_end":42},{"text":"     /// [`Trait`]: trait.Trait.html","highlight_start":1,"highlight_end":37},{"text":"     pub type Event < $ event_generic_param $","highlight_start":1,"highlight_end":46},{"text":"    (, $ instance $ (= $ event_default_instance) ?) ? > = RawEvent < $","highlight_start":1,"highlight_end":71},{"text":"    ($ generic_type), * $ (, $ instance) ? > ; #","highlight_start":1,"highlight_end":49},{"text":"    [derive","highlight_start":1,"highlight_end":12},{"text":"     (Clone, PartialEq, Eq, $ crate :: codec :: Encode, $ crate :: codec ::","highlight_start":1,"highlight_end":76},{"text":"      Decode, $ crate :: RuntimeDebug,)] /// Events for this module.","highlight_start":1,"highlight_end":69},{"text":"     ///","highlight_start":1,"highlight_end":9},{"text":"     $ (# [$ attr]) * pub enum RawEvent < $ ($ generic_param), * $","highlight_start":1,"highlight_end":67},{"text":"    (, $ instance) ? >","highlight_start":1,"highlight_end":23},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        $ ($ events) * $","highlight_start":1,"highlight_end":25},{"text":"        (# [doc (hidden)] # [codec (skip)] PhantomData","highlight_start":1,"highlight_end":55},{"text":"         ($ crate :: sp_std :: marker :: PhantomData < $ instance >),) ?","highlight_start":1,"highlight_end":73},{"text":"    } impl < $ ($ generic_param), * $ (, $ instance) ? > From < RawEvent < $","highlight_start":1,"highlight_end":77},{"text":"    ($ generic_param), * $ (, $ instance) ? >> for ()","highlight_start":1,"highlight_end":54},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        fn from (_ : RawEvent < $ ($ generic_param), * $ (, $ instance) ? >)","highlight_start":1,"highlight_end":77},{"text":"        -> () { () }","highlight_start":1,"highlight_end":21},{"text":"    } impl < $ ($ generic_param), * $ (, $ instance) ? > RawEvent < $","highlight_start":1,"highlight_end":70},{"text":"    ($ generic_param), * $ (, $ instance) ? >","highlight_start":1,"highlight_end":46},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        # [allow (dead_code)] pub fn metadata () -> & 'static","highlight_start":1,"highlight_end":62},{"text":"        [$ crate :: event :: EventMetadata]","highlight_start":1,"highlight_end":44},{"text":"        { $ crate :: __events_to_metadata ! (; $ ($ events) *) }","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"} ; (@ cannot_parse $ ty : ty) =>","highlight_start":1,"highlight_end":34},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    compile_error !","highlight_start":1,"highlight_end":20},{"text":"    (concat !","highlight_start":1,"highlight_end":14},{"text":"     (\"The type `\", stringify ! ($ ty),","highlight_start":1,"highlight_end":40},{"text":"      \"` can't be parsed as an unnamed one, please name it `Name = \",","highlight_start":1,"highlight_end":70},{"text":"      stringify ! ($ ty), \"`\")) ;","highlight_start":1,"highlight_end":34},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::__decl_generic_event!","def_site_span":{"file_name":"<::frame_support::event::__decl_generic_event macros>","byte_start":0,"byte_end":4819,"line_start":1,"line_end":111,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":61},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ ($ tt : tt) * } ;) =>","highlight_start":1,"highlight_end":27},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ tt) * } ; { } ;)","highlight_start":1,"highlight_end":79},{"text":"    ;","highlight_start":1,"highlight_end":6},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     < $ generic : ident as $ trait : path > :: $ trait_type : ident $ (,) ?","highlight_start":1,"highlight_end":77},{"text":"     { $ ($ events : tt) * }","highlight_start":1,"highlight_end":29},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ generate $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":61},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ events) * } ;","highlight_start":1,"highlight_end":76},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         $ ($ parsed) *, $ trait_type = < $ generic as $ trait > :: $","highlight_start":1,"highlight_end":70},{"text":"         trait_type","highlight_start":1,"highlight_end":20},{"text":"     } ;) ;","highlight_start":1,"highlight_end":12},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     $ generic_rename : ident = $ generic_type : ty $ (,) ?","highlight_start":1,"highlight_end":60},{"text":"     { $ ($ events : tt) * }","highlight_start":1,"highlight_end":29},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ generate $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":61},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ events) * } ;","highlight_start":1,"highlight_end":76},{"text":"     { $ ($ parsed) *, $ generic_rename = $ generic_type } ;) ;","highlight_start":1,"highlight_end":64},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_rename : ident = $ generic_type : ty, $ ($ rest : tt) * } ;","highlight_start":1,"highlight_end":73},{"text":" { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":31},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ rest) * } ;","highlight_start":1,"highlight_end":74},{"text":"     { $ ($ parsed) *, $ generic_rename = $ generic_type } ;) ;","highlight_start":1,"highlight_end":64},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" {","highlight_start":1,"highlight_end":3},{"text":"     < $ generic : ident as $ trait : path > :: $ trait_type : ident, $","highlight_start":1,"highlight_end":72},{"text":"     ($ rest : tt) *","highlight_start":1,"highlight_end":21},{"text":" } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    $ crate :: __decl_generic_event !","highlight_start":1,"highlight_end":38},{"text":"    (@ format_generic $ (# [$ attr]) * ; $ event_generic_param ; $","highlight_start":1,"highlight_end":67},{"text":"     ($ instance $ (= $ event_default_instance) ?) ? ; { $ ($ rest) * } ;","highlight_start":1,"highlight_end":74},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         $ ($ parsed) *, $ trait_type = < $ generic as $ trait > :: $","highlight_start":1,"highlight_end":70},{"text":"         trait_type","highlight_start":1,"highlight_end":20},{"text":"     } ;) ;","highlight_start":1,"highlight_end":12},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_type : ty, $ ($ rest : tt) * } ; { $ ($ parsed : tt) * } ;) =>","highlight_start":1,"highlight_end":76},{"text":"{ $ crate :: __decl_generic_event ! (@ cannot_parse $ generic_type) ; } ;","highlight_start":1,"highlight_end":74},{"text":"(@ format_generic $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":78},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ generic_type : ty { $ ($ events : tt) * } } ; { $ ($ parsed : tt) * } ;)","highlight_start":1,"highlight_end":78},{"text":"=> { $ crate :: __decl_generic_event ! (@ cannot_parse $ generic_type) ; } ;","highlight_start":1,"highlight_end":77},{"text":"(@ generate $ (# [$ attr : meta]) * ; $ event_generic_param : ident ; $","highlight_start":1,"highlight_end":72},{"text":" ($ instance : ident $ (= $ event_default_instance : path) ?) ? ;","highlight_start":1,"highlight_end":66},{"text":" { $ ($ events : tt) * } ;","highlight_start":1,"highlight_end":27},{"text":" { , $ ($ generic_param : ident = $ generic_type : ty), * } ;) =>","highlight_start":1,"highlight_end":66},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    /// [`RawEvent`] specialized for the configuration [`Trait`]","highlight_start":1,"highlight_end":65},{"text":"     ///","highlight_start":1,"highlight_end":9},{"text":"     /// [`RawEvent`]: enum.RawEvent.html","highlight_start":1,"highlight_end":42},{"text":"     /// [`Trait`]: trait.Trait.html","highlight_start":1,"highlight_end":37},{"text":"     pub type Event < $ event_generic_param $","highlight_start":1,"highlight_end":46},{"text":"    (, $ instance $ (= $ event_default_instance) ?) ? > = RawEvent < $","highlight_start":1,"highlight_end":71},{"text":"    ($ generic_type), * $ (, $ instance) ? > ; #","highlight_start":1,"highlight_end":49},{"text":"    [derive","highlight_start":1,"highlight_end":12},{"text":"     (Clone, PartialEq, Eq, $ crate :: codec :: Encode, $ crate :: codec ::","highlight_start":1,"highlight_end":76},{"text":"      Decode, $ crate :: RuntimeDebug,)] /// Events for this module.","highlight_start":1,"highlight_end":69},{"text":"     ///","highlight_start":1,"highlight_end":9},{"text":"     $ (# [$ attr]) * pub enum RawEvent < $ ($ generic_param), * $","highlight_start":1,"highlight_end":67},{"text":"    (, $ instance) ? >","highlight_start":1,"highlight_end":23},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        $ ($ events) * $","highlight_start":1,"highlight_end":25},{"text":"        (# [doc (hidden)] # [codec (skip)] PhantomData","highlight_start":1,"highlight_end":55},{"text":"         ($ crate :: sp_std :: marker :: PhantomData < $ instance >),) ?","highlight_start":1,"highlight_end":73},{"text":"    } impl < $ ($ generic_param), * $ (, $ instance) ? > From < RawEvent < $","highlight_start":1,"highlight_end":77},{"text":"    ($ generic_param), * $ (, $ instance) ? >> for ()","highlight_start":1,"highlight_end":54},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        fn from (_ : RawEvent < $ ($ generic_param), * $ (, $ instance) ? >)","highlight_start":1,"highlight_end":77},{"text":"        -> () { () }","highlight_start":1,"highlight_end":21},{"text":"    } impl < $ ($ generic_param), * $ (, $ instance) ? > RawEvent < $","highlight_start":1,"highlight_end":70},{"text":"    ($ generic_param), * $ (, $ instance) ? >","highlight_start":1,"highlight_end":46},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        # [allow (dead_code)] pub fn metadata () -> & 'static","highlight_start":1,"highlight_end":62},{"text":"        [$ crate :: event :: EventMetadata]","highlight_start":1,"highlight_end":44},{"text":"        { $ crate :: __events_to_metadata ! (; $ ($ events) *) }","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"} ; (@ cannot_parse $ ty : ty) =>","highlight_start":1,"highlight_end":34},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    compile_error !","highlight_start":1,"highlight_end":20},{"text":"    (concat !","highlight_start":1,"highlight_end":14},{"text":"     (\"The type `\", stringify ! ($ ty),","highlight_start":1,"highlight_end":40},{"text":"      \"` can't be parsed as an unnamed one, please name it `Name = \",","highlight_start":1,"highlight_end":70},{"text":"      stringify ! ($ ty), \"`\")) ;","highlight_start":1,"highlight_end":34},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":9962,"byte_end":9968,"line_start":346,"line_end":346,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"\t\t\t\tRawEvent::DIDKey(","highlight_start":15,"highlight_end":21}],"label":"variant or associated item not found in `RawEvent<_, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `DIDKey` found for enum `RawEvent<_, _>` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:346:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m346\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                RawEvent::DIDKey(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RawEvent<_, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m373\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdecl_event!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m374\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub enum Event<T>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m375\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    where\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m376\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    <T as frame_system::Trait>::AccountId,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m392\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m393\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `DIDKey` not found here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"unused import: `Pair`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":448,"byte_end":452,"line_start":13,"line_end":13,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"use sp_core::{RuntimeDebug, sr25519, Pair};","highlight_start":38,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `Pair`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:13:38\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse sp_core::{RuntimeDebug, sr25519, Pair};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"message":"aborting due to 28 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 28 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0061, E0277, E0308, E0599, E0609.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0061, E0277, E0308, E0599, E0609.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
